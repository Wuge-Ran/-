<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Promise</title>
</head>

<body>
    <script>
        //All
        /**
         * finally()方法返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。
         * 在 finally 之后，还可以继续 then。并且会将值原封不动的传递给后面的 then
         **/
        Promise.prototype.finally = function (callback) {
            return this.then((res) => {
                return Promise.resolve(callback()).then(() => res);
            }, (err) => {
                return Promise.resolve(callback()).then(() => {
                    throw err
                });
            })

        }
        let fn = () => {
            return Promise.reject('这里只有返回被拒绝的 promise 或者 throw 一个错误，才会影响当前 finally 返回的新 promise 的决议')
        }
        var p = Promise.reject('这里只有返回被拒绝的 promise 或者 throw 一个错误，才会影响当前 finally 返回的新 promise 的决议')
            .then(() => {
                return 1
            });

        p.then((res) => {
            console.log('==res', res)
        }, (err) => {
            console.log('=err', err)

        })
        //All
        /**
         * Promise.all(iterable)方法返回一个 Promise 实例，
         * 此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），
         * 此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。
         **/
        Promise.all = function (arr) {
            let resArr = [];
            let length = 0;
            return new Promise((resolve, reject) => {
                arr.forEach((element, index) => {
                    Promise.resolve(element).then(res => {
                        resArr[index] = res;
                        length++;
                        if (length === arr.length) {
                            resolve(resArr);
                        }
                    }, err => {
                        reject(err);
                    })
                });
            })
        }
        //race
        /**
         * Promise.race(iterable)方法返回一个 promise，
         * 一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。
         **/
        Promise.race = function (arr) {
            return new Promise((resolve, reject) => {
                arr.forEach(ele => {
                    Promise.resolve(ele).then(resolve(res),reject(err))
                })
            })
        }
    </script>
</body>

</html>